// in the case n = 1 or 2, its simple
// if n >= 3, we choose (maxSum-1)/2+1 as the starting value at index, every step to the right/left, value there is 1 less until it's 1, then 
// calculate the sum of the array, compare it to the maxSum, and make the value larger or smaller accordingly

class Solution {
    public  int maxValue(int n, int index, int maxSum) {
        if ( n == 1 )
            return maxSum;
        else if ( n == 2 )
            return ( int ) Math.ceil( maxSum / 2 );
        else
        {
            int start = 1;
            int end = maxSum;
            int result = -1;
            while ( start <= end )
            {
                int mid = start + ( end - start )/2;
                int sum = left_sum(0, index, mid ) + right_sum( index +1 , n-1, mid-1);
                if( sum <= maxSum ) 
                {
                    result = mid;
                    start = mid +1;
                }
                else
                    end = mid - 1;
            }
            return result;
        }
    }
    
    // calculate the sum in [start_index, end_index], where the element at end_index is val
    private int left_sum(int start_index, int end_index, int val)
    {
        if(start_index == end_index)
            return val;
        else
        {
            int l = end_index - start_index + 1;
            // 2 cases:
            // if val >= length_of_interval, then the element at start_index is val-(l-1)
            // if val < length_of_interval, then the element at end_index-(val-1) is already 1.
            if ( val >= l )
                return ( ( val - (l-1)) + val ) * l / 2;
            else
                return ( val + 1 ) * val / 2 + ( l - val );
            
        }
    }
    
    // similar to left_sum, the only diffenrence is we should consider the case start_index > right_index
    private int right_sum( int start_index, int end_index, int val )
    {
        if(start_index > end_index)
            return 0;
        else if(start_index == end_index)
            return val;
        else
        {
            int l = end_index - start_index + 1;
            if ( val >= l )
                return ( (val-(l-1)) + val ) * l / 2;
            else
                return ( val + 1 ) * val / 2 + ( l - val );
            
        }
    }

}
